//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0.1-b01-fcs 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2007.08.17 at 01:20:51 PM BST 
//


package psidev.psi.ms.mzml.mapping.jaxb;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.bind.annotation.*;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.ByteArrayInputStream;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;


/**
 * <p>Java class for RunType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="RunType">
 *   &lt;complexContent>
 *     &lt;extension base="{http://psi.hupo.org/schema_revision/mzML_0.93}ParamGroupType">
 *       &lt;sequence>
 *         &lt;element name="sourceFileRefList" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;sequence>
 *                   &lt;element name="sourceFileRef" maxOccurs="unbounded" minOccurs="0">
 *                     &lt;complexType>
 *                       &lt;complexContent>
 *                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                           &lt;attribute name="ref" type="{http://www.w3.org/2001/XMLSchema}anyURI" />
 *                         &lt;/restriction>
 *                       &lt;/complexContent>
 *                     &lt;/complexType>
 *                   &lt;/element>
 *                 &lt;/sequence>
 *                 &lt;attribute name="count" type="{http://www.w3.org/2001/XMLSchema}nonNegativeInteger" />
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="spectrumList" type="{http://psi.hupo.org/schema_revision/mzML_0.93}SpectrumListType"/>
 *       &lt;/sequence>
 *       &lt;attribute name="id" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="instrumentRef" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="sampleRef" type="{http://www.w3.org/2001/XMLSchema}anyURI" />
 *       &lt;attribute name="timeStamp" type="{http://www.w3.org/2001/XMLSchema}dateTime" />
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "RunType", propOrder = {
    "sourceFileRefList",
    "spectrumList"
})
public class RunType
    extends ParamGroupType
{

    protected RunType.SourceFileRefList sourceFileRefList;
    @XmlElement(required = true)
    protected SpectrumListType spectrumList;
    @XmlAttribute(required = true)
    protected String id;
    @XmlAttribute(required = true)
    protected String instrumentRef;
    @XmlAttribute
    protected String sampleRef;
    @XmlAttribute
    protected XMLGregorianCalendar timeStamp;


    private String elementName = "run";

    public RunType() {}

    public RunType(String xmlSnippet) {
        parseXml(xmlSnippet);
    }

    public RunType(Element element) {
        create(element);
    }

    ///////////////////
    // utilities

    private void parseXml(String xmlSnippet) {
        Document document = null;
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            ByteArrayInputStream str = new ByteArrayInputStream(xmlSnippet.getBytes());
            document = builder.parse( str );
        } catch ( Exception e ) {
            e.printStackTrace();
        }


        // we always expect a String representing a single xml tag, not a list of xml tags!
        if (document != null) {
            NodeList nl = document.getElementsByTagName(elementName);
            if (nl.getLength() == 1) {
                Element ele = (Element) nl.item(0);
                create(ele);
            } else {
                throw new IllegalStateException("Expected only one '" + elementName + "' element, but found: " + nl.getLength());
            }
        }

    }

    protected void create(Node node) {
        Element ele = (Element) node;
        if (ele != null) {
            // load attributes
            String id = ele.getAttribute("id");
            if (!id.equals("")) { // getAttribute returns empty String if no value was specified
                setId(id);
            }
            String instrumentRef = ele.getAttribute("instrumentRef");
            if (!instrumentRef.equals("")) { // getAttribute returns empty String if no value was specified
                setInstrumentRef(instrumentRef);
            }
            String sampleRef = ele.getAttribute("sampleRef");
            if (!sampleRef.equals("")) { // getAttribute returns empty String if no value was specified
                setSampleRef(sampleRef);
            }
            String timeStamp = ele.getAttribute("timeStamp");
            if (!timeStamp.equals("")) { // getAttribute returns empty String if no value was specified
                try {
                    setTimeStamp(DatatypeFactory.newInstance().newXMLGregorianCalendar(timeStamp));
                } catch (DatatypeConfigurationException e) {
                    throw new IllegalStateException("Could not create a XMLGregorianCalendar " +
                            "from String representation: " + timeStamp, e);
                }
            }
            // load elements
            NodeList nl = ele.getElementsByTagName("spectrumList");
            // we only expect one such element!
            if (nl.getLength() == 1) {
                spectrumList = new SpectrumListType((Element) nl.item(0));
            } else {
                throw new IllegalStateException("Expected only one 'spectrumList' element, but found: " + nl.getLength());
            }
            nl = null;
            nl = ele.getElementsByTagName("sourceFileRefList");
            // we only expect one such element!
            if (nl.getLength() == 1) {
                sourceFileRefList = new SourceFileRefList((Element) nl.item(0));
            } else {
                throw new IllegalStateException("Expected only one 'sourceFileRefList' element, but found: " + nl.getLength());
            }
            // inherited form ParamGroupType
            super.create(node);
        }
    }

    ////////////////////
    // Getter + Setter

    /**
     * Gets the value of the sourceFileRefList property.
     * 
     * @return
     *     possible object is
     *     {@link RunType.SourceFileRefList }
     *     
     */
    public RunType.SourceFileRefList getSourceFileRefList() {
        return sourceFileRefList;
    }

    /**
     * Sets the value of the sourceFileRefList property.
     * 
     * @param value
     *     allowed object is
     *     {@link RunType.SourceFileRefList }
     *     
     */
    public void setSourceFileRefList(RunType.SourceFileRefList value) {
        this.sourceFileRefList = value;
    }

    /**
     * Gets the value of the spectrumList property.
     * 
     * @return
     *     possible object is
     *     {@link SpectrumListType }
     *     
     */
    public SpectrumListType getSpectrumList() {
        return spectrumList;
    }

    /**
     * Sets the value of the spectrumList property.
     * 
     * @param value
     *     allowed object is
     *     {@link SpectrumListType }
     *     
     */
    public void setSpectrumList(SpectrumListType value) {
        this.spectrumList = value;
    }

    /**
     * Gets the value of the id property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setId(String value) {
        this.id = value;
    }

    /**
     * Gets the value of the instrumentRef property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getInstrumentRef() {
        return instrumentRef;
    }

    /**
     * Sets the value of the instrumentRef property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setInstrumentRef(String value) {
        this.instrumentRef = value;
    }

    /**
     * Gets the value of the sampleRef property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSampleRef() {
        return sampleRef;
    }

    /**
     * Sets the value of the sampleRef property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSampleRef(String value) {
        this.sampleRef = value;
    }

    /**
     * Gets the value of the timeStamp property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public XMLGregorianCalendar getTimeStamp() {
        return timeStamp;
    }

    /**
     * Sets the value of the timeStamp property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setTimeStamp(XMLGregorianCalendar value) {
        this.timeStamp = value;
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence>
     *         &lt;element name="sourceFileRef" maxOccurs="unbounded" minOccurs="0">
     *           &lt;complexType>
     *             &lt;complexContent>
     *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 &lt;attribute name="ref" type="{http://www.w3.org/2001/XMLSchema}anyURI" />
     *               &lt;/restriction>
     *             &lt;/complexContent>
     *           &lt;/complexType>
     *         &lt;/element>
     *       &lt;/sequence>
     *       &lt;attribute name="count" type="{http://www.w3.org/2001/XMLSchema}nonNegativeInteger" />
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "sourceFileRef"
    })
    public static class SourceFileRefList {

        @XmlElement(required = true)
        protected List<RunType.SourceFileRefList.SourceFileRef> sourceFileRef;
        @XmlAttribute
        protected BigInteger count;


        private String elementName = "sourceFileRefList";

        public SourceFileRefList() {}

        public SourceFileRefList(String xmlSnippet) {
            parseXml(xmlSnippet);
        }

        public SourceFileRefList(Element element) {
            create(element);
        }

        ///////////////////
        // utilities

        private void parseXml(String xmlSnippet) {
            Document document = null;
            try {
                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
                DocumentBuilder builder = factory.newDocumentBuilder();
                ByteArrayInputStream str = new ByteArrayInputStream(xmlSnippet.getBytes());
                document = builder.parse( str );
            } catch ( Exception e ) {
                e.printStackTrace();
            }


            // we always expect a String representing a single xml tag, not a list of xml tags!
            if (document != null) {
                NodeList nl = document.getElementsByTagName(elementName);
                if (nl.getLength() == 1) {
                    Element ele = (Element) nl.item(0);
                    create(ele);
                } else {
                    throw new IllegalStateException("Expected only one '" + elementName + "' element, but found: " + nl.getLength());
                }
            }

        }

        private void create(Node node) {
            Element ele = (Element) node;
            if (ele != null) {
                // load attributes
                String count = ele.getAttribute("count");
                if (!count.equals("")) { // getAttribute returns empty String if no value was specified
                    setCount(new BigInteger(count));
                }
                // load elements
                NodeList nl = ele.getElementsByTagName("sourceFileRef");
                for ( int i = 0; i < nl.getLength(); i++ ) {
                    this.getSourceFileRef().add(new SourceFileRef((Element) nl.item(i)));
                }


            }
        }

        ////////////////////
        // Getter + Setter

       /**
         * Gets the value of the sourceFileRef property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the sourceFileRef property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getSourceFileRef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link RunType.SourceFileRefList.SourceFileRef }
         * 
         * 
         */
        public List<RunType.SourceFileRefList.SourceFileRef> getSourceFileRef() {
            if (sourceFileRef == null) {
                sourceFileRef = new ArrayList<RunType.SourceFileRefList.SourceFileRef>();
            }
            return this.sourceFileRef;
        }

        /**
         * Gets the value of the count property.
         * 
         * @return
         *     possible object is
         *     {@link BigInteger }
         *     
         */
        public BigInteger getCount() {
            return count;
        }

        /**
         * Sets the value of the count property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigInteger }
         *     
         */
        public void setCount(BigInteger value) {
            this.count = value;
        }


        /**
         * <p>Java class for anonymous complex type.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.
         * 
         * <pre>
         * &lt;complexType>
         *   &lt;complexContent>
         *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       &lt;attribute name="ref" type="{http://www.w3.org/2001/XMLSchema}anyURI" />
         *     &lt;/restriction>
         *   &lt;/complexContent>
         * &lt;/complexType>
         * </pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class SourceFileRef {

            @XmlAttribute
            protected String ref;


            private String elementName = "sourceFileRef";

            public SourceFileRef() {}

            public SourceFileRef(String xmlSnippet) {
                parseXml(xmlSnippet);
            }

            public SourceFileRef(Element element) {
                create(element);
            }

            ///////////////////
            // utilities

            private void parseXml(String xmlSnippet) {
                Document document = null;
                try {
                    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
                    DocumentBuilder builder = factory.newDocumentBuilder();
                    ByteArrayInputStream str = new ByteArrayInputStream(xmlSnippet.getBytes());
                    document = builder.parse( str );
                } catch ( Exception e ) {
                    e.printStackTrace();
                }


                // we always expect a String representing a single xml tag, not a list of xml tags!
                if (document != null) {
                    NodeList nl = document.getElementsByTagName(elementName);
                    if (nl.getLength() == 1) {
                        Element ele = (Element) nl.item(0);
                        create(ele);
                    } else {
                        throw new IllegalStateException("Expected only one '" + elementName + "' element, but found: " + nl.getLength());
                    }
                }

            }

            private void create(Node node) {
                Element ele = (Element) node;
                if (ele != null) {
                    // load attributes
                    String ref = ele.getAttribute("ref");
                    if (!ref.equals("")) { // getAttribute returns empty String if no value was specified
                        setRef(ref);
                    }
                    // load elements
                    
                }
            }

            ////////////////////
            // Getter + Setter

            /**
             * Gets the value of the ref property.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getRef() {
                return ref;
            }

            /**
             * Sets the value of the ref property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             */
            public void setRef(String value) {
                this.ref = value;
            }

        }

    }

}
